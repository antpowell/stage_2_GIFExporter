{"version":3,"sources":["js\\LZWEncoder.js"],"names":["LZWEncoder","exports","EOF","imgW","imgH","pixAry","initCodeSize","remaining","curPixel","BITS","HSIZE","n_bits","maxbits","maxcode","maxmaxcode","htab","codetab","hsize","free_ent","clear_flg","g_init_bits","ClearCode","EOFCode","cur_accum","cur_bits","masks","a_count","accum","width","height","pixels","color_depth","Math","max","char_out","c","outs","flush_char","cl_block","cl_hash","output","i","compress","init_bits","fcode","ent","disp","hsize_reg","hshift","MAXCODE","nextPixel","outer_loop","encode","os","write","writeArray","pix","code","apply","arguments"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;AASAA,aAAa,sBAAW;;AAEvB,KAAIC,UAAU,EAAd;AACA,KAAIC,MAAM,CAAC,CAAX;AACA,KAAIC,IAAJ;AACA,KAAIC,IAAJ;AACA,KAAIC,MAAJ;AACA,KAAIC,YAAJ;AACA,KAAIC,SAAJ;AACA,KAAIC,QAAJ;;AAEA;AACA;AACA;AACA;;AAEA,KAAIC,OAAO,EAAX;AACA,KAAIC,QAAQ,IAAZ,CAjBuB,CAiBL;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAIC,MAAJ,CA5BuB,CA4BX;AACZ,KAAIC,UAAUH,IAAd,CA7BuB,CA6BH;AACpB,KAAII,OAAJ,CA9BuB,CA8BV;AACb,KAAIC,aAAa,KAAKL,IAAtB,CA/BuB,CA+BK;AAC5B,KAAIM,OAAO,EAAX;AACA,KAAIC,UAAU,EAAd;AACA,KAAIC,QAAQP,KAAZ,CAlCuB,CAkCJ;AACnB,KAAIQ,WAAW,CAAf,CAnCuB,CAmCL;;AAElB;AACA;;AAEA,KAAIC,YAAY,KAAhB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAIC,WAAJ;AACA,KAAIC,SAAJ;AACA,KAAIC,OAAJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAIC,YAAY,CAAhB;AACA,KAAIC,WAAW,CAAf;AACA,KAAIC,QAAQ,CAAC,MAAD,EAAS,MAAT,EAAiB,MAAjB,EAAyB,MAAzB,EAAiC,MAAjC,EAAyC,MAAzC,EAAiD,MAAjD,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,MAAzE,EAAiF,MAAjF,EAAyF,MAAzF,EAAiG,MAAjG,EAAyG,MAAzG,EAAiH,MAAjH,EAAyH,MAAzH,EAAiI,MAAjI,CAAZ;;AAEA;AACA,KAAIC,OAAJ;;AAEA;AACA,KAAIC,QAAQ,EAAZ;;AAEA,KAAI3B,aAAaC,QAAQD,UAAR,GAAqB,SAASA,UAAT,CAAoB4B,KAApB,EAA2BC,MAA3B,EAAmCC,MAAnC,EAA2CC,WAA3C,EAAwD;AAC7F5B,SAAOyB,KAAP;AACAxB,SAAOyB,MAAP;AACAxB,WAASyB,MAAT;AACAxB,iBAAe0B,KAAKC,GAAL,CAAS,CAAT,EAAYF,WAAZ,CAAf;AACA,EALD;;AAOA;AACA;AACA,KAAIG,WAAW,SAASA,QAAT,CAAkBC,CAAlB,EAAqBC,IAArB,EAA2B;AACzCT,QAAMD,SAAN,IAAmBS,CAAnB;AACA,MAAIT,WAAW,GAAf,EAAoBW,WAAWD,IAAX;AACpB,EAHD;;AAKA;AACA;;AAEA,KAAIE,WAAW,SAASA,QAAT,CAAkBF,IAAlB,EAAwB;AACtCG,UAAQtB,KAAR;AACAC,aAAWG,YAAY,CAAvB;AACAF,cAAY,IAAZ;AACAqB,SAAOnB,SAAP,EAAkBe,IAAlB;AACA,EALD;;AAOA;AACA,KAAIG,UAAU,SAASA,OAAT,CAAiBtB,KAAjB,EAAwB;AACrC,OAAK,IAAIwB,IAAI,CAAb,EAAgBA,IAAIxB,KAApB,EAA2B,EAAEwB,CAA7B;AAAgC1B,QAAK0B,CAAL,IAAU,CAAC,CAAX;AAAhC;AACA,EAFD;;AAIA,KAAIC,WAAWzC,QAAQyC,QAAR,GAAmB,SAASA,QAAT,CAAkBC,SAAlB,EAA6BP,IAA7B,EAAmC;;AAEpE,MAAIQ,KAAJ;AACA,MAAIH,CAAJ,CAHoE,CAG7D;AACP,MAAIN,CAAJ;AACA,MAAIU,GAAJ;AACA,MAAIC,IAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,MAAJ;;AAEA;AACA5B,gBAAcuB,SAAd;;AAEA;AACAxB,cAAY,KAAZ;AACAR,WAASS,WAAT;AACAP,YAAUoC,QAAQtC,MAAR,CAAV;;AAEAU,cAAY,KAAMsB,YAAY,CAA9B;AACArB,YAAUD,YAAY,CAAtB;AACAH,aAAWG,YAAY,CAAvB;;AAEAK,YAAU,CAAV,CAtBoE,CAsBvD;;AAEbmB,QAAMK,WAAN;;AAEAF,WAAS,CAAT;AACA,OAAKJ,QAAQ3B,KAAb,EAAoB2B,QAAQ,KAA5B,EAAmCA,SAAS,CAA5C;AACC,KAAEI,MAAF;AADD,GAEAA,SAAS,IAAIA,MAAb,CA7BoE,CA6B/C;;AAErBD,cAAY9B,KAAZ;AACAsB,UAAQQ,SAAR,EAhCoE,CAgChD;;AAEpBP,SAAOnB,SAAP,EAAkBe,IAAlB;;AAEAe,cAAY,OAAO,CAAChB,IAAIe,WAAL,KAAqBhD,GAA5B,EAAiC;AAC5C0C,WAAQ,CAACT,KAAKvB,OAAN,IAAiBiC,GAAzB;AACAJ,OAAKN,KAAKa,MAAN,GAAgBH,GAApB,CAF4C,CAEnB;;AAEzB,OAAI9B,KAAK0B,CAAL,KAAWG,KAAf,EAAsB;AACrBC,UAAM7B,QAAQyB,CAAR,CAAN;AACA;AACA,IAHD,MAKK,IAAI1B,KAAK0B,CAAL,KAAW,CAAf,EAAkB;AAAE;;AAExBK,WAAOC,YAAYN,CAAnB,CAFsB,CAEA;AACtB,QAAIA,MAAM,CAAV,EAAaK,OAAO,CAAP;;AAEb,OAAG;AACF,SAAI,CAACL,KAAKK,IAAN,IAAc,CAAlB,EACCL,KAAKM,SAAL;;AAED,SAAIhC,KAAK0B,CAAL,KAAWG,KAAf,EAAsB;AACrBC,YAAM7B,QAAQyB,CAAR,CAAN;AACA,eAASU,UAAT;AACA;AACD,KARD,QAQSpC,KAAK0B,CAAL,KAAW,CARpB;AASA;;AAEDD,UAAOK,GAAP,EAAYT,IAAZ;AACAS,SAAMV,CAAN;AACA,OAAIjB,WAAWJ,UAAf,EAA2B;AAC1BE,YAAQyB,CAAR,IAAavB,UAAb,CAD0B,CACD;AACzBH,SAAK0B,CAAL,IAAUG,KAAV;AACA,IAHD,MAIKN,SAASF,IAAT;AACL;;AAED;AACAI,SAAOK,GAAP,EAAYT,IAAZ;AACAI,SAAOlB,OAAP,EAAgBc,IAAhB;AACA,EAzED;;AA2EA;AACA,KAAIgB,SAASnD,QAAQmD,MAAR,GAAiB,SAASA,MAAT,CAAgBC,EAAhB,EAAoB;AACjDA,KAAGC,KAAH,CAAShD,YAAT,EADiD,CACzB;AACxBC,cAAYJ,OAAOC,IAAnB,CAFiD,CAExB;AACzBI,aAAW,CAAX;AACAkC,WAASpC,eAAe,CAAxB,EAA2B+C,EAA3B,EAJiD,CAIjB;AAChCA,KAAGC,KAAH,CAAS,CAAT,EALiD,CAKpC;AACb,EAND;;AAQA;AACA,KAAIjB,aAAa,SAASA,UAAT,CAAoBD,IAApB,EAA0B;AAC1C,MAAIV,UAAU,CAAd,EAAiB;AAChBU,QAAKkB,KAAL,CAAW5B,OAAX;AACAU,QAAKmB,UAAL,CAAgB5B,KAAhB,EAAuBD,OAAvB;AACAA,aAAU,CAAV;AACA;AACD,EAND;;AAQA,KAAIuB,UAAU,SAASA,OAAT,CAAiBtC,MAAjB,EAAyB;AACtC,SAAO,CAAC,KAAKA,MAAN,IAAgB,CAAvB;AACA,EAFD;;AAIA;AACA;AACA;;AAEA,KAAIuC,YAAY,SAASA,SAAT,GAAqB;AACpC,MAAI3C,cAAc,CAAlB,EAAqB,OAAOL,GAAP;AACrB,IAAEK,SAAF;AACA,MAAIiD,MAAMnD,OAAOG,UAAP,CAAV;AACA,SAAOgD,MAAM,IAAb;AACA,EALD;;AAOA,KAAIhB,SAAS,SAASA,MAAT,CAAgBiB,IAAhB,EAAsBrB,IAAtB,EAA4B;;AAExCb,eAAaE,MAAMD,QAAN,CAAb;;AAEA,MAAIA,WAAW,CAAf,EAAkBD,aAAckC,QAAQjC,QAAtB,CAAlB,KACKD,YAAYkC,IAAZ;;AAELjC,cAAYb,MAAZ;;AAEA,SAAOa,YAAY,CAAnB,EAAsB;AACrBU,YAAUX,YAAY,IAAtB,EAA6Ba,IAA7B;AACAb,iBAAc,CAAd;AACAC,eAAY,CAAZ;AACA;;AAED;AACA;;AAEA,MAAIN,WAAWL,OAAX,IAAsBM,SAA1B,EAAqC;;AAEpC,OAAIA,SAAJ,EAAe;;AAEdN,cAAUoC,QAAQtC,SAASS,WAAjB,CAAV;AACAD,gBAAY,KAAZ;AAEA,IALD,MAKO;;AAEN,MAAER,MAAF;AACA,QAAIA,UAAUC,OAAd,EAAuBC,UAAUC,UAAV,CAAvB,KACKD,UAAUoC,QAAQtC,MAAR,CAAV;AACL;AACD;;AAED,MAAI8C,QAAQnC,OAAZ,EAAqB;;AAEpB;AACA,UAAOE,WAAW,CAAlB,EAAqB;AACpBU,aAAUX,YAAY,IAAtB,EAA6Ba,IAA7B;AACAb,kBAAc,CAAd;AACAC,gBAAY,CAAZ;AACA;;AAEDa,cAAWD,IAAX;AACA;AACD,EA5CD;;AA8CApC,YAAW0D,KAAX,CAAiB,IAAjB,EAAuBC,SAAvB;AACA,QAAO1D,OAAP;AACA,CA3QD","file":"LZWEncoder.5792b753.map","sourceRoot":"..","sourcesContent":["/**\r\n * This class handles LZW encoding\r\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nLZWEncoder = function() {\r\n\r\n\tvar exports = {};\r\n\tvar EOF = -1;\r\n\tvar imgW;\r\n\tvar imgH;\r\n\tvar pixAry;\r\n\tvar initCodeSize;\r\n\tvar remaining;\r\n\tvar curPixel;\r\n\r\n\t// GIFCOMPR.C - GIF Image compression routines\r\n\t// Lempel-Ziv compression based on 'compress'. GIF modifications by\r\n\t// David Rowley (mgardi@watdcsu.waterloo.edu)\r\n\t// General DEFINEs\r\n\r\n\tvar BITS = 12;\r\n\tvar HSIZE = 5003; // 80% occupancy\r\n\r\n\t// GIF Image compression - modified 'compress'\r\n\t// Based on: compress.c - File compression ala IEEE Computer, June 1984.\r\n\t// By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\r\n\t// Jim McKie (decvax!mcvax!jim)\r\n\t// Steve Davies (decvax!vax135!petsd!peora!srd)\r\n\t// Ken Turkowski (decvax!decwrl!turtlevax!ken)\r\n\t// James A. Woods (decvax!ihnp4!ames!jaw)\r\n\t// Joe Orost (decvax!vax135!petsd!joe)\r\n\r\n\tvar n_bits; // number of bits/code\r\n\tvar maxbits = BITS; // user settable max # bits/code\r\n\tvar maxcode; // maximum code, given n_bits\r\n\tvar maxmaxcode = 1 << BITS; // should NEVER generate this code\r\n\tvar htab = [];\r\n\tvar codetab = [];\r\n\tvar hsize = HSIZE; // for dynamic table sizing\r\n\tvar free_ent = 0; // first unused entry\r\n\r\n\t// block compression parameters -- after all codes are used up,\r\n\t// and compression rate changes, start over.\r\n\r\n\tvar clear_flg = false;\r\n\r\n\t// Algorithm: use open addressing double hashing (no chaining) on the\r\n\t// prefix code / next character combination. We do a variant of Knuth's\r\n\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\r\n\t// secondary probe. Here, the modular division first probe is gives way\r\n\t// to a faster exclusive-or manipulation. Also do block compression with\r\n\t// an adaptive reset, whereby the code table is cleared when the compression\r\n\t// ratio decreases, but after the table fills. The variable-length output\r\n\t// codes are re-sized at this point, and a special CLEAR code is generated\r\n\t// for the decompressor. Late addition: construct the table according to\r\n\t// file size for noticeable speed improvement on small files. Please direct\r\n\t// questions about this implementation to ames!jaw.\r\n\r\n\tvar g_init_bits;\r\n\tvar ClearCode;\r\n\tvar EOFCode;\r\n\r\n\t// output\r\n\t// Output the given code.\r\n\t// Inputs:\r\n\t// code: A n_bits-bit integer. If == -1, then EOF. This assumes\r\n\t// that n_bits =< wordsize - 1.\r\n\t// Outputs:\r\n\t// Outputs code to the file.\r\n\t// Assumptions:\r\n\t// Chars are 8 bits long.\r\n\t// Algorithm:\r\n\t// Maintain a BITS character long buffer (so that 8 codes will\r\n\t// fit in it exactly). Use the VAX insv instruction to insert each\r\n\t// code in turn. When the buffer fills up empty it and start over.\r\n\r\n\tvar cur_accum = 0;\r\n\tvar cur_bits = 0;\r\n\tvar masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\r\n\t// Number of characters so far in this 'packet'\r\n\tvar a_count;\r\n\r\n\t// Define the storage for the packet accumulator\r\n\tvar accum = [];\r\n\r\n\tvar LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\r\n\t\timgW = width;\r\n\t\timgH = height;\r\n\t\tpixAry = pixels;\r\n\t\tinitCodeSize = Math.max(2, color_depth);\r\n\t};\r\n\r\n\t// Add a character to the end of the current packet, and if it is 254\r\n\t// characters, flush the packet to disk.\r\n\tvar char_out = function char_out(c, outs) {\r\n\t\taccum[a_count++] = c;\r\n\t\tif (a_count >= 254) flush_char(outs);\r\n\t};\r\n\r\n\t// Clear out the hash table\r\n\t// table clear for block compress\r\n\r\n\tvar cl_block = function cl_block(outs) {\r\n\t\tcl_hash(hsize);\r\n\t\tfree_ent = ClearCode + 2;\r\n\t\tclear_flg = true;\r\n\t\toutput(ClearCode, outs);\r\n\t};\r\n\r\n\t// reset code table\r\n\tvar cl_hash = function cl_hash(hsize) {\r\n\t\tfor (var i = 0; i < hsize; ++i) htab[i] = -1;\r\n\t};\r\n\r\n\tvar compress = exports.compress = function compress(init_bits, outs) {\r\n\r\n\t\tvar fcode;\r\n\t\tvar i; /* = 0 */\r\n\t\tvar c;\r\n\t\tvar ent;\r\n\t\tvar disp;\r\n\t\tvar hsize_reg;\r\n\t\tvar hshift;\r\n\r\n\t\t// Set up the globals: g_init_bits - initial number of bits\r\n\t\tg_init_bits = init_bits;\r\n\r\n\t\t// Set up the necessary values\r\n\t\tclear_flg = false;\r\n\t\tn_bits = g_init_bits;\r\n\t\tmaxcode = MAXCODE(n_bits);\r\n\r\n\t\tClearCode = 1 << (init_bits - 1);\r\n\t\tEOFCode = ClearCode + 1;\r\n\t\tfree_ent = ClearCode + 2;\r\n\r\n\t\ta_count = 0; // clear packet\r\n\r\n\t\tent = nextPixel();\r\n\r\n\t\thshift = 0;\r\n\t\tfor (fcode = hsize; fcode < 65536; fcode *= 2)\r\n\t\t\t++hshift;\r\n\t\thshift = 8 - hshift; // set hash code range bound\r\n\r\n\t\thsize_reg = hsize;\r\n\t\tcl_hash(hsize_reg); // clear hash table\r\n\r\n\t\toutput(ClearCode, outs);\r\n\r\n\t\touter_loop: while ((c = nextPixel()) != EOF) {\r\n\t\t\tfcode = (c << maxbits) + ent;\r\n\t\t\ti = (c << hshift) ^ ent; // xor hashing\r\n\r\n\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\tent = codetab[i];\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\telse if (htab[i] >= 0) { // non-empty slot\r\n\r\n\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\r\n\t\t\t\tif (i === 0) disp = 1;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif ((i -= disp) < 0)\r\n\t\t\t\t\t\ti += hsize_reg;\r\n\r\n\t\t\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\t\t\tent = codetab[i];\r\n\t\t\t\t\t\tcontinue outer_loop;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (htab[i] >= 0);\r\n\t\t\t}\r\n\r\n\t\t\toutput(ent, outs);\r\n\t\t\tent = c;\r\n\t\t\tif (free_ent < maxmaxcode) {\r\n\t\t\t\tcodetab[i] = free_ent++; // code -> hashtable\r\n\t\t\t\thtab[i] = fcode;\r\n\t\t\t}\r\n\t\t\telse cl_block(outs);\r\n\t\t}\r\n\r\n\t\t// Put out the final code.\r\n\t\toutput(ent, outs);\r\n\t\toutput(EOFCode, outs);\r\n\t};\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\tvar encode = exports.encode = function encode(os) {\r\n\t\tos.write(initCodeSize); // write \"initial code size\" byte\r\n\t\tremaining = imgW * imgH; // reset navigation variables\r\n\t\tcurPixel = 0;\r\n\t\tcompress(initCodeSize + 1, os); // compress and write the pixel data\r\n\t\tos.write(0); // write block terminator\r\n\t};\r\n\r\n\t// Flush the packet to disk, and reset the accumulator\r\n\tvar flush_char = function flush_char(outs) {\r\n\t\tif (a_count > 0) {\r\n\t\t\touts.write(a_count);\r\n\t\t\touts.writeArray(accum, a_count);\r\n\t\t\ta_count = 0;\r\n\t\t}\r\n\t};\r\n\r\n\tvar MAXCODE = function MAXCODE(n_bits) {\r\n\t\treturn (1 << n_bits) - 1;\r\n\t};\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// Return the next pixel from the image\r\n\t// ----------------------------------------------------------------------------\r\n\r\n\tvar nextPixel = function nextPixel() {\r\n\t\tif (remaining === 0) return EOF;\r\n\t\t--remaining;\r\n\t\tvar pix = pixAry[curPixel++];\r\n\t\treturn pix & 0xff;\r\n\t};\r\n\r\n\tvar output = function output(code, outs) {\r\n\r\n\t\tcur_accum &= masks[cur_bits];\r\n\r\n\t\tif (cur_bits > 0) cur_accum |= (code << cur_bits);\r\n\t\telse cur_accum = code;\r\n\r\n\t\tcur_bits += n_bits;\r\n\r\n\t\twhile (cur_bits >= 8) {\r\n\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\tcur_accum >>= 8;\r\n\t\t\tcur_bits -= 8;\r\n\t\t}\r\n\r\n\t\t// If the next entry is going to be too big for the code size,\r\n\t\t// then increase it, if possible.\r\n\r\n\t\tif (free_ent > maxcode || clear_flg) {\r\n\r\n\t\t\tif (clear_flg) {\r\n\r\n\t\t\t\tmaxcode = MAXCODE(n_bits = g_init_bits);\r\n\t\t\t\tclear_flg = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t++n_bits;\r\n\t\t\t\tif (n_bits == maxbits) maxcode = maxmaxcode;\r\n\t\t\t\telse maxcode = MAXCODE(n_bits);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (code == EOFCode) {\r\n\r\n\t\t\t// At EOF, write the rest of the buffer.\r\n\t\t\twhile (cur_bits > 0) {\r\n\t\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\t\tcur_accum >>= 8;\r\n\t\t\t\tcur_bits -= 8;\r\n\t\t\t}\r\n\r\n\t\t\tflush_char(outs);\r\n\t\t}\r\n\t};\r\n\r\n\tLZWEncoder.apply(this, arguments);\r\n\treturn exports;\r\n};\r\n"]}