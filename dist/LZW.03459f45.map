{"version":3,"sources":["src\\LZW.ts"],"names":[],"mappings":"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","file":"LZW.03459f45.map","sourceRoot":"..","sourcesContent":["/**\r\n * This class handles LZW encoding\r\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @author Anthony Powell (TypeScript version)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nimport { EncodedImage } from './encoded.image';\r\nexport class LZWEncoder {\r\n\tprivate readonly EOF = 1;\r\n\r\n\t// GIFCOMPR.C - GIF Image compression routines\r\n\t// Lempel-Ziv compression based on 'compress'. GIF modifications by\r\n\t// David Rowley (mgardi@watdcsu.waterloo.edu)\r\n\t// General DEFINEs\r\n\r\n\tprivate readonly BITS = 12;\r\n\tprivate readonly HSIZE = 5003;\r\n\r\n\tprivate _imgW: number;\r\n\tprivate _imgH: number;\r\n\tprivate _pixels: number[];\r\n\tprivate _initCodeSize: number;\r\n\tprivate _remaining: number;\r\n\tprivate _curPixel: number;\r\n\r\n\t// GIF Image compression - modified 'compress'\r\n\t// Based on: compress.c - File compression ala IEEE Computer, June 1984.\r\n\t// By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\r\n\t// Jim McKie (decvax!mcvax!jim)\r\n\t// Steve Davies (decvax!vax135!petsd!peora!srd)\r\n\t// Ken Turkowski (decvax!decwrl!turtlevax!ken)\r\n\t// James A. Woods (decvax!ihnp4!ames!jaw)\r\n\t// Joe Orost (decvax!vax135!petsd!joe)\r\n\r\n\tprivate _n_bits: number; // number of bits/code\r\n\tprivate _maxbits = this.BITS; // user settable max # bits/code\r\n\tprivate _maxcode: number; // maximum code, given n_bits\r\n\tprivate _maxmaxcode = 1 << this.BITS; // should NEVER generate this code\r\n\tprivate _htab: number[] = [];\r\n\tprivate _codetab: number[] = [];\r\n\tprivate _hsize = this.HSIZE; // for dynamic table sizing\r\n\tprivate _free_ent = 0; // first unused entry\r\n\r\n\t// block compression parameters -- after all codes are used up,\r\n\t// and compression rate changes, start over.\r\n\r\n\tprivate _clear_flg = false;\r\n\r\n\t// Algorithm: use open addressing double hashing (no chaining) on the\r\n\t// prefix code / next character combination. We do a variant of Knuth's\r\n\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\r\n\t// secondary probe. Here, the modular division first probe is gives way\r\n\t// to a faster exclusive-or manipulation. Also do block compression with\r\n\t// an adaptive reset, whereby the code table is cleared when the compression\r\n\t// ratio decreases, but after the table fills. The variable-length output\r\n\t// codes are re-sized at this point, and a special CLEAR code is generated\r\n\t// for the decompressor. Late addition: construct the table according to\r\n\t// file size for noticeable speed improvement on small files. Please direct\r\n\t// questions about this implementation to ames!jaw.\r\n\r\n\tprivate _g_init_bits: number;\r\n\tprivate _ClearCode: number;\r\n\tprivate _EOFCode: number;\r\n\r\n\t// output\r\n\t// Output the given code.\r\n\t// Inputs:\r\n\t// code: A n_bits-bit integer. If == -1, then EOF. This assumes\r\n\t// that n_bits =< wordsize - 1.\r\n\t// Outputs:\r\n\t// Outputs code to the file.\r\n\t// Assumptions:\r\n\t// Chars are 8 bits long.\r\n\t// Algorithm:\r\n\t// Maintain a BITS character long buffer (so that 8 codes will\r\n\t// fit in it exactly). Use the VAX insv instruction to insert each\r\n\t// code in turn. When the buffer fills up empty it and start over.\r\n\r\n\tprivate _cur_accum = 0;\r\n\tprivate _cur_bits = 0;\r\n\tprivate _masks = [\r\n\t\t0x0000,\r\n\t\t0x0001,\r\n\t\t0x0003,\r\n\t\t0x0007,\r\n\t\t0x000f,\r\n\t\t0x001f,\r\n\t\t0x003f,\r\n\t\t0x007f,\r\n\t\t0x00ff,\r\n\t\t0x01ff,\r\n\t\t0x03ff,\r\n\t\t0x07ff,\r\n\t\t0x0fff,\r\n\t\t0x1fff,\r\n\t\t0x3fff,\r\n\t\t0x7fff,\r\n\t\t0xffff,\r\n\t];\r\n\r\n\t// Number of characters so far in this 'packet'\r\n\tprivate _a_count: number;\r\n\r\n\t// Define the storage for the packet accumulator\r\n\tprivate _accum: number[] = [];\r\n\r\n\tconstructor(\r\n\t\twidth: number,\r\n\t\theight: number,\r\n\t\tpixels: number[],\r\n\t\tcolorDepth: number\r\n\t) {\r\n\t\tthis._imgW = width;\r\n\t\tthis._imgH = height;\r\n\t\tthis._pixels = pixels;\r\n\t\tthis._initCodeSize = Math.max(2, colorDepth);\r\n\t}\r\n\r\n\t// Add a character to the end of the current packet, and if it is 254\r\n\t// characters, flush the packet to disk.\r\n\tprivate writeCharToPacket(c: number, outs: EncodedImage): void {\r\n\t\tthis._accum[this._a_count++] = c;\r\n\t\tif (this._a_count >= 254) this.flush_char(outs);\r\n\t}\r\n\r\n\t// Clear out the hash table\r\n\t// table clear for block compress\r\n\r\n\tprivate cl_block(outs: EncodedImage): void {\r\n\t\tthis.cl_hash(this._hsize);\r\n\t\tthis._free_ent = this._ClearCode + 2;\r\n\t\tthis._clear_flg = true;\r\n\t\tthis.output(this._ClearCode, outs);\r\n\t}\r\n\r\n\t// reset code table\r\n\tpublic cl_hash(hsize: number): void {\r\n\t\tfor (let i = 0; i < hsize; ++i) this._htab[i] = -1;\r\n\t}\r\n\r\n\tprivate compress(init_bits: number, outs: EncodedImage) {\r\n\t\tlet fcode;\r\n\t\tlet i; /* = 0 */\r\n\t\tlet c;\r\n\t\tlet ent;\r\n\t\tlet disp;\r\n\t\tlet hsize_reg;\r\n\t\tlet hshift;\r\n\r\n\t\t// Set up the globals: g_init_bits - initial number of bits\r\n\t\tthis._g_init_bits = init_bits;\r\n\r\n\t\t// Set up the necessary values\r\n\t\tthis._clear_flg = false;\r\n\t\tthis._n_bits = this._g_init_bits;\r\n\t\tthis._maxcode = this.MAXCODE(this._n_bits);\r\n\r\n\t\tthis._ClearCode = 1 << (init_bits - 1);\r\n\t\tthis._EOFCode = this._ClearCode + 1;\r\n\t\tthis._free_ent = this._ClearCode + 2;\r\n\r\n\t\tthis._a_count = 0; // clear packet\r\n\r\n\t\tent = this.nextPixel();\r\n\r\n\t\thshift = 0;\r\n\t\tfor (fcode = this._hsize; fcode < 65536; fcode *= 2) ++hshift;\r\n\t\thshift = 8 - hshift; // set hash code range bound\r\n\r\n\t\thsize_reg = this._hsize;\r\n\t\tthis.cl_hash(hsize_reg); // clear hash table\r\n\r\n\t\tthis.output(this._ClearCode, outs);\r\n\r\n\t\touter_loop: while ((c = this.nextPixel()) != this.EOF) {\r\n\t\t\tfcode = (c << this._maxbits) + ent;\r\n\t\t\ti = (c << hshift) ^ ent; // xor hashing\r\n\r\n\t\t\tif (this._htab[i] == fcode) {\r\n\t\t\t\tent = this._codetab[i];\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (this._htab[i] >= 0) {\r\n\t\t\t\t// non-empty slot\r\n\r\n\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\r\n\t\t\t\tif (i === 0) disp = 1;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif ((i -= disp) < 0) i += hsize_reg;\r\n\r\n\t\t\t\t\tif (this._htab[i] == fcode) {\r\n\t\t\t\t\t\tent = this._codetab[i];\r\n\t\t\t\t\t\tcontinue outer_loop;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (this._htab[i] >= 0);\r\n\t\t\t}\r\n\r\n\t\t\tthis.output(ent, outs);\r\n\t\t\tent = c;\r\n\t\t\tif (this._free_ent < this._maxmaxcode) {\r\n\t\t\t\tthis._codetab[i] = this._free_ent++; // code -> hashtable\r\n\t\t\t\tthis._htab[i] = fcode;\r\n\t\t\t} else this.cl_block(outs);\r\n\t\t}\r\n\r\n\t\t// Put out the final code.\r\n\t\tthis.output(ent, outs);\r\n\t\tthis.output(this._EOFCode, outs);\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\tpublic encode(os: EncodedImage) {\r\n\t\tos.write(this._initCodeSize); // write \"initial code size\" byte\r\n\t\tthis._remaining = this._imgW * this._imgH; // reset navigation variables\r\n\t\tthis._curPixel = 0;\r\n\t\tthis.compress(this._initCodeSize + 1, os); // compress and write the pixel data\r\n\t\tos.write(0); // write block terminator\r\n\t}\r\n\r\n\t// Flush the packet to disk, and reset the accumulator\r\n\tprivate flush_char(outs: EncodedImage) {\r\n\t\tif (this._a_count > 0) {\r\n\t\t\touts.write(this._a_count);\r\n\t\t\touts.writeArray(this._accum, this._a_count);\r\n\t\t\tthis._a_count = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate MAXCODE(n_bits: number) {\r\n\t\treturn (1 << n_bits) - 1;\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// Return the next pixel from the image\r\n\t// ----------------------------------------------------------------------------\r\n\r\n\tprivate nextPixel() {\r\n\t\tif (this._remaining === 0) return this.EOF;\r\n\t\t--this._remaining;\r\n\t\tlet pix = this._pixels[this._curPixel++];\r\n\t\treturn pix & 0xff;\r\n\t}\r\n\r\n\tprivate output(code: number, outs: EncodedImage) {\r\n\t\tthis._cur_accum &= this._masks[this._cur_bits];\r\n\r\n\t\tif (this._cur_bits > 0) this._cur_accum |= code << this._cur_bits;\r\n\t\telse this._cur_accum = code;\r\n\r\n\t\tthis._cur_bits += this._n_bits;\r\n\r\n\t\twhile (this._cur_bits >= 8) {\r\n\t\t\tthis.writeCharToPacket(this._cur_accum & 0xff, outs);\r\n\t\t\tthis._cur_accum >>= 8;\r\n\t\t\tthis._cur_bits -= 8;\r\n\t\t}\r\n\r\n\t\t// If the next entry is going to be too big for the code size,\r\n\t\t// then increase it, if possible.\r\n\r\n\t\tif (this._free_ent > this._maxcode || this._clear_flg) {\r\n\t\t\tif (this._clear_flg) {\r\n\t\t\t\tthis._maxcode = this.MAXCODE((this._n_bits = this._g_init_bits));\r\n\t\t\t\tthis._clear_flg = false;\r\n\t\t\t} else {\r\n\t\t\t\t++this._n_bits;\r\n\t\t\t\tif (this._n_bits == this._maxbits) this._maxcode = this._maxmaxcode;\r\n\t\t\t\telse this._maxcode = this.MAXCODE(this._n_bits);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (code == this._EOFCode) {\r\n\t\t\t// At EOF, write the rest of the buffer.\r\n\t\t\twhile (this._cur_bits > 0) {\r\n\t\t\t\tthis.writeCharToPacket(this._cur_accum & 0xff, outs);\r\n\t\t\t\tthis._cur_accum >>= 8;\r\n\t\t\t\tthis._cur_bits -= 8;\r\n\t\t\t}\r\n\r\n\t\t\tthis.flush_char(outs);\r\n\t\t}\r\n\t}\r\n}\r\n"]}