{"version":3,"sources":["src\\lzw.service.ts"],"names":[],"mappings":"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","file":"lzw.service.d93058d8.map","sourceRoot":"..","sourcesContent":["/**\r\n * This class handles LZW encoding\r\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nimport { EncodedImage } from './encoded.image';\r\n\r\nLZWEncoder = function() {\r\n\tvar exports = {};\r\n\tvar EOF = -1;\r\n\tvar imgW;\r\n\tvar imgH;\r\n\tvar pixAry;\r\n\tvar initCodeSize;\r\n\tvar remaining;\r\n\tvar curPixel;\r\n\r\n\t// GIFCOMPR.C - GIF Image compression routines\r\n\t// Lempel-Ziv compression based on 'compress'. GIF modifications by\r\n\t// David Rowley (mgardi@watdcsu.waterloo.edu)\r\n\t// General DEFINEs\r\n\r\n\tvar BITS = 12;\r\n\tvar HSIZE = 5003; // 80% occupancy\r\n\r\n\t// GIF Image compression - modified 'compress'\r\n\t// Based on: compress.c - File compression ala IEEE Computer, June 1984.\r\n\t// By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\r\n\t// Jim McKie (decvax!mcvax!jim)\r\n\t// Steve Davies (decvax!vax135!petsd!peora!srd)\r\n\t// Ken Turkowski (decvax!decwrl!turtlevax!ken)\r\n\t// James A. Woods (decvax!ihnp4!ames!jaw)\r\n\t// Joe Orost (decvax!vax135!petsd!joe)\r\n\r\n\tvar n_bits; // number of bits/code\r\n\tvar maxbits = BITS; // user settable max # bits/code\r\n\tvar maxcode; // maximum code, given n_bits\r\n\tvar maxmaxcode = 1 << BITS; // should NEVER generate this code\r\n\tvar htab = [];\r\n\tvar codetab = [];\r\n\tvar hsize = HSIZE; // for dynamic table sizing\r\n\tvar free_ent = 0; // first unused entry\r\n\r\n\t// block compression parameters -- after all codes are used up,\r\n\t// and compression rate changes, start over.\r\n\r\n\tvar clear_flg = false;\r\n\r\n\t// Algorithm: use open addressing double hashing (no chaining) on the\r\n\t// prefix code / next character combination. We do a variant of Knuth's\r\n\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\r\n\t// secondary probe. Here, the modular division first probe is gives way\r\n\t// to a faster exclusive-or manipulation. Also do block compression with\r\n\t// an adaptive reset, whereby the code table is cleared when the compression\r\n\t// ratio decreases, but after the table fills. The variable-length output\r\n\t// codes are re-sized at this point, and a special CLEAR code is generated\r\n\t// for the decompressor. Late addition: construct the table according to\r\n\t// file size for noticeable speed improvement on small files. Please direct\r\n\t// questions about this implementation to ames!jaw.\r\n\r\n\tvar g_init_bits;\r\n\tvar ClearCode;\r\n\tvar EOFCode;\r\n\r\n\t// output\r\n\t// Output the given code.\r\n\t// Inputs:\r\n\t// code: A n_bits-bit integer. If == -1, then EOF. This assumes\r\n\t// that n_bits =< wordsize - 1.\r\n\t// Outputs:\r\n\t// Outputs code to the file.\r\n\t// Assumptions:\r\n\t// Chars are 8 bits long.\r\n\t// Algorithm:\r\n\t// Maintain a BITS character long buffer (so that 8 codes will\r\n\t// fit in it exactly). Use the VAX insv instruction to insert each\r\n\t// code in turn. When the buffer fills up empty it and start over.\r\n\r\n\tvar cur_accum = 0;\r\n\tvar cur_bits = 0;\r\n\tvar masks = [\r\n\t\t0x0000,\r\n\t\t0x0001,\r\n\t\t0x0003,\r\n\t\t0x0007,\r\n\t\t0x000f,\r\n\t\t0x001f,\r\n\t\t0x003f,\r\n\t\t0x007f,\r\n\t\t0x00ff,\r\n\t\t0x01ff,\r\n\t\t0x03ff,\r\n\t\t0x07ff,\r\n\t\t0x0fff,\r\n\t\t0x1fff,\r\n\t\t0x3fff,\r\n\t\t0x7fff,\r\n\t\t0xffff,\r\n\t];\r\n\r\n\t// Number of characters so far in this 'packet'\r\n\tvar a_count;\r\n\r\n\t// Define the storage for the packet accumulator\r\n\tvar accum = [];\r\n\r\n\tvar LZWEncoder = (exports.LZWEncoder = function LZWEncoder(\r\n\t\twidth,\r\n\t\theight,\r\n\t\tpixels,\r\n\t\tcolor_depth\r\n\t) {\r\n\t\timgW = width;\r\n\t\timgH = height;\r\n\t\tpixAry = pixels;\r\n\t\tinitCodeSize = Math.max(2, color_depth);\r\n\t});\r\n\r\n\t// Add a character to the end of the current packet, and if it is 254\r\n\t// characters, flush the packet to disk.\r\n\tvar char_out = function char_out(c, outs) {\r\n\t\taccum[a_count++] = c;\r\n\t\tif (a_count >= 254) flush_char(outs);\r\n\t};\r\n\r\n\t// Clear out the hash table\r\n\t// table clear for block compress\r\n\r\n\tvar cl_block = function cl_block(outs) {\r\n\t\tcl_hash(hsize);\r\n\t\tfree_ent = ClearCode + 2;\r\n\t\tclear_flg = true;\r\n\t\toutput(ClearCode, outs);\r\n\t};\r\n\r\n\t// reset code table\r\n\tvar cl_hash = function cl_hash(hsize) {\r\n\t\tfor (var i = 0; i < hsize; ++i) htab[i] = -1;\r\n\t};\r\n\r\n\tvar compress = (exports.compress = function compress(init_bits, outs) {\r\n\t\tvar fcode;\r\n\t\tvar i; /* = 0 */\r\n\t\tvar c;\r\n\t\tvar ent;\r\n\t\tvar disp;\r\n\t\tvar hsize_reg;\r\n\t\tvar hshift;\r\n\r\n\t\t// Set up the globals: g_init_bits - initial number of bits\r\n\t\tg_init_bits = init_bits;\r\n\r\n\t\t// Set up the necessary values\r\n\t\tclear_flg = false;\r\n\t\tn_bits = g_init_bits;\r\n\t\tmaxcode = MAXCODE(n_bits);\r\n\r\n\t\tClearCode = 1 << (init_bits - 1);\r\n\t\tEOFCode = ClearCode + 1;\r\n\t\tfree_ent = ClearCode + 2;\r\n\r\n\t\ta_count = 0; // clear packet\r\n\r\n\t\tent = nextPixel();\r\n\r\n\t\thshift = 0;\r\n\t\tfor (fcode = hsize; fcode < 65536; fcode *= 2) ++hshift;\r\n\t\thshift = 8 - hshift; // set hash code range bound\r\n\r\n\t\thsize_reg = hsize;\r\n\t\tcl_hash(hsize_reg); // clear hash table\r\n\r\n\t\toutput(ClearCode, outs);\r\n\r\n\t\touter_loop: while ((c = nextPixel()) != EOF) {\r\n\t\t\tfcode = (c << maxbits) + ent;\r\n\t\t\ti = (c << hshift) ^ ent; // xor hashing\r\n\r\n\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\tent = codetab[i];\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (htab[i] >= 0) {\r\n\t\t\t\t// non-empty slot\r\n\r\n\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\r\n\t\t\t\tif (i === 0) disp = 1;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif ((i -= disp) < 0) i += hsize_reg;\r\n\r\n\t\t\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\t\t\tent = codetab[i];\r\n\t\t\t\t\t\tcontinue outer_loop;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (htab[i] >= 0);\r\n\t\t\t}\r\n\r\n\t\t\toutput(ent, outs);\r\n\t\t\tent = c;\r\n\t\t\tif (free_ent < maxmaxcode) {\r\n\t\t\t\tcodetab[i] = free_ent++; // code -> hashtable\r\n\t\t\t\thtab[i] = fcode;\r\n\t\t\t} else cl_block(outs);\r\n\t\t}\r\n\r\n\t\t// Put out the final code.\r\n\t\toutput(ent, outs);\r\n\t\toutput(EOFCode, outs);\r\n\t});\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\tvar encode = (exports.encode = function encode(os) {\r\n\t\tconsole.log(os);\r\n\t\tos.write(initCodeSize); // write \"initial code size\" byte\r\n\t\tremaining = imgW * imgH; // reset navigation variables\r\n\t\tcurPixel = 0;\r\n\t\tcompress(initCodeSize + 1, os); // compress and write the pixel data\r\n\t\tos.write(0); // write block terminator\r\n\t});\r\n\r\n\t// Flush the packet to disk, and reset the accumulator\r\n\tvar flush_char = function flush_char(outs) {\r\n\t\tif (a_count > 0) {\r\n\t\t\touts.write(a_count);\r\n\t\t\touts.writeArray(accum, a_count);\r\n\t\t\ta_count = 0;\r\n\t\t}\r\n\t};\r\n\r\n\tvar MAXCODE = function MAXCODE(n_bits) {\r\n\t\treturn (1 << n_bits) - 1;\r\n\t};\r\n\r\n\t// ----------------------------------------------------------------------------\r\n\t// Return the next pixel from the image\r\n\t// ----------------------------------------------------------------------------\r\n\r\n\tvar nextPixel = function nextPixel() {\r\n\t\tif (remaining === 0) return EOF;\r\n\t\t--remaining;\r\n\t\tvar pix = pixAry[curPixel++];\r\n\t\treturn pix & 0xff;\r\n\t};\r\n\r\n\tvar output = function output(code, outs) {\r\n\t\tcur_accum &= masks[cur_bits];\r\n\r\n\t\tif (cur_bits > 0) cur_accum |= code << cur_bits;\r\n\t\telse cur_accum = code;\r\n\r\n\t\tcur_bits += n_bits;\r\n\r\n\t\twhile (cur_bits >= 8) {\r\n\t\t\tchar_out(cur_accum & 0xff, outs);\r\n\t\t\tcur_accum >>= 8;\r\n\t\t\tcur_bits -= 8;\r\n\t\t}\r\n\r\n\t\t// If the next entry is going to be too big for the code size,\r\n\t\t// then increase it, if possible.\r\n\r\n\t\tif (free_ent > maxcode || clear_flg) {\r\n\t\t\tif (clear_flg) {\r\n\t\t\t\tmaxcode = MAXCODE((n_bits = g_init_bits));\r\n\t\t\t\tclear_flg = false;\r\n\t\t\t} else {\r\n\t\t\t\t++n_bits;\r\n\t\t\t\tif (n_bits == maxbits) maxcode = maxmaxcode;\r\n\t\t\t\telse maxcode = MAXCODE(n_bits);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (code == EOFCode) {\r\n\t\t\t// At EOF, write the rest of the buffer.\r\n\t\t\twhile (cur_bits > 0) {\r\n\t\t\t\tchar_out(cur_accum & 0xff, outs);\r\n\t\t\t\tcur_accum >>= 8;\r\n\t\t\t\tcur_bits -= 8;\r\n\t\t\t}\r\n\r\n\t\t\tflush_char(outs);\r\n\t\t}\r\n\t};\r\n\r\n\tLZWEncoder.apply(this, arguments);\r\n\treturn exports;\r\n};\r\n\r\nonmessage = e => {\r\n\tconst {\r\n\t\tdata: { width, height, data, colorDepth, gif },\r\n\t} = e;\r\n\r\n\tconst encoder = new LZWEncoder(width, height, data, colorDepth);\r\n\tencoder.encode(gif as EncodedImage);\r\n\tconsole.log(gif);\r\n};\r\n"]}